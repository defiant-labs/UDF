diff --git sys/cam/scsi/scsi_cd.c sys/cam/scsi/scsi_cd.c
index 5e88a97..55ee959 100644
--- sys/cam/scsi/scsi_cd.c
+++ sys/cam/scsi/scsi_cd.c
@@ -60,6 +60,7 @@ __FBSDID("$FreeBSD$");
 #include <sys/cdio.h>
 #include <sys/cdrio.h>
 #include <sys/dvdio.h>
+#include <sys/udfio.h>
 #include <sys/devicestat.h>
 #include <sys/sysctl.h>
 #include <sys/taskqueue.h>
@@ -284,6 +285,22 @@ static	int		cdsendkey(struct cam_periph *periph,
 static	int		cdreaddvdstructure(struct cam_periph *periph,
 					   struct dvd_struct *dvdstruct);
 
+/* added for UDF */
+static int udfreaddiscinfo(struct cam_periph *periph, struct udf_session_info *usi);
+static	int 		cdgetconf(struct cam_periph *periph, u_int8_t *data,
+				  u_int32_t len, uint8_t rt, 
+				  uint16_t startfeature, u_int32_t sense_flags);
+static 	int		cdreaddiscinfo(struct cam_periph *periph, uint8_t *data,
+				       uint32_t len, uint32_t sense_flags);
+static 	int 		cdreadtrackinfo(struct cam_periph *periph, 
+					uint8_t *data, uint32_t len, 
+					uint32_t trackno, 
+					uint32_t sense_flags);
+static	int		cdrecordedsequentially(struct cam_periph *periph,
+					       int *sequentual_media,
+					       int *link_block_penalty);
+/* end of UDF */
+
 static struct periph_driver cddriver =
 {
 	cdinit, "cd",
@@ -2716,6 +2733,18 @@ cdioctl(struct disk *dp, u_long cmd, void *addr, int flag, struct thread *td)
 
 		break;
 	}
+	case UDFIOTEST: {
+		struct udf_session_info  *usi;
+
+		usi = (struct udf_session_info *)addr;
+
+		CAM_DEBUG(periph->path, CAM_DEBUG_SUBTRACE, 
+			  ("trying to do UDFIOTEST\n"));
+		
+		error = udfreaddiscinfo(periph, usi);
+
+		break;
+		}
 	default:
 		cam_periph_lock(periph);
 		error = cam_periph_ioctl(periph, cmd, addr, cderror);
@@ -2735,6 +2764,417 @@ cdioctl(struct disk *dp, u_long cmd, void *addr, int flag, struct thread *td)
 	return (error);
 }
 
+/* Added for UDF. */
+static int
+cdrecordedsequentially(struct cam_periph *periph, int *sequentual_media,
+    int *link_block_penalty) 
+{
+	struct scsi_get_conf_header *gch;
+	struct scsi_get_conf_feature_generic *fg;
+	uint32_t datalen, curprofile;
+	uint16_t featcode;
+	int error, databuflen;
+	int seqfeature, cancelseq, linkblkpenalty;
+
+	seqfeature = 0;
+	cancelseq = 0;
+	linkblkpenalty = 0;
+	
+	gch = malloc(sizeof (*gch) + 16, M_SCSICD, M_WAITOK | M_ZERO);
+
+	cam_periph_lock(periph);
+
+	error = cdgetconf(periph, (u_int8_t *)gch, sizeof (*gch) + 16,
+		GC_RT_ALLFEATURES, GC_FC_PROFILE_LIST, SF_NO_PRINT);
+	if (error)
+		goto out;
+
+	curprofile = scsi_2btoul(gch->cur_profile);
+	datalen = scsi_4btoul(gch->data_len) - 4;
+	fg = (struct scsi_get_conf_feature_generic *)(gch + 1); 
+	databuflen = 16;
+	while (datalen > 0) {
+		featcode = scsi_2btoul(fg->feature_code);
+
+		/* This is voodoo from NetBSD's logic. Apparently some 
+		drives misreport some features. */
+		if (fg->byte3 & GC_CURRENT) {
+			if (featcode == 0x21 || /*Incremental Streaming Writable*/
+			    featcode == 0x2B || /*DVD+R read and opt. write*/
+			    featcode == 0x2D) /*CD Track at Once*/
+				seqfeature = 1;
+
+			if (curprofile == 0x0a /*CD-RW*/ && 
+			    (featcode == 0x26 || /*Restricted Overwrite*/
+			    featcode == 0x2C || /*Rigid Restricted Overwrite*/
+			    featcode == 0x28)) /*MRW Formatted media*/
+				cancelseq = 1;
+
+			if (featcode == 0x21) {
+				linkblkpenalty = 0;
+printf("linkblkpenalty set to %d\n", linkblkpenalty);
+			}
+		}
+
+printf("gch: %p, fg: %p\n", gch, fg);
+printf("feature_code: %x, additional_len: %d, current %d, seqfeature: %d, cancelseq: %d\n", featcode, fg->additional_len, fg->byte3 & GC_CURRENT,  seqfeature, cancelseq);
+
+		datalen -= 4 + fg->additional_len;
+		databuflen -= 4 + fg->additional_len;
+		
+		if (databuflen < 4) {
+printf("cdgetconf again, sizeof gch+16: %ld\n", sizeof(*gch)+16);
+			error = cdgetconf(periph, (u_int8_t *)gch, sizeof (*gch) + 16,
+				GC_RT_ALLFEATURES, featcode + 1, /*sense_flags*/SF_NO_PRINT);
+			if (error)
+				goto out;
+			fg = (struct scsi_get_conf_feature_generic *)(gch + 1); 
+			databuflen = 16;
+		} else {
+			fg = (struct scsi_get_conf_feature_generic *)((uint8_t *)fg + 4 + fg->additional_len);
+		}
+	}
+
+	if (cancelseq == 1)
+		seqfeature = 0;
+
+	*sequentual_media = seqfeature;
+	*link_block_penalty = linkblkpenalty;
+
+out:
+	cam_periph_unlock(periph);
+	free(gch, M_SCSICD);
+
+	return error;
+}
+
+static int
+udfreaddiscinfo(struct cam_periph *periph, struct udf_session_info /*{
+	uint32_t session_num;
+
+	uint16_t sector_size;
+	uint16_t num_sessions;
+	uint32_t session_start_addr;
+	uint32_t session_end_addr;
+
+	uint16_t num_tracks;
+	uint8_t  first_track;
+	uint16_t session_first_track;
+	uint16_t session_last_track;
+}*/ *usi)
+{
+	struct scsi_read_disc_info_data *rdi;
+	struct scsi_read_track_info_data *ti;
+	uint32_t track_start_addr, track_size, free_blocks, nwa, lra;
+	uint16_t track, sessret;
+	uint8_t lsb, msb;
+	int error, seqmedia, linkblkpenalty, lra_valid, nwa_valid;
+
+	/* Read get config and header data. */
+	error = cdrecordedsequentially(periph, &seqmedia, &linkblkpenalty);
+	if (error)
+		return error;
+
+	rdi = malloc(sizeof(struct scsi_read_disc_info_data),
+		M_SCSICD, M_WAITOK | M_ZERO);
+	ti = malloc(sizeof(struct scsi_read_track_info_data),
+		M_SCSICD, M_WAITOK | M_ZERO);
+
+	cam_periph_lock(periph);
+
+	error = cdreaddiscinfo(periph, (uint8_t *)rdi, sizeof (*rdi), 
+	    SF_NO_PRINT);
+	if (error != 0)
+		goto out;
+
+	usi->num_sessions = rdi->num_sessions_lsb | (rdi->num_sessions_msb << 8);
+printf("num_sessions: %d, session_num: %d\n", usi->num_sessions, usi->session_num);
+	if (usi->session_num == 0)
+		usi->session_num = usi->num_sessions;
+
+	usi->first_track = rdi->num_first_track;
+
+	lsb = rdi->last_track_last_session_lsb;
+	msb = rdi->last_track_last_session_msb;
+	usi->num_tracks = ((msb << 8) | lsb) - usi->first_track + 1;
+
+printf("last_track_last_session: %u\n", (rdi->last_track_last_session_msb << 8) | rdi->last_track_last_session_lsb);
+printf("first_track_last_session: %u\n", (rdi->first_track_last_session_msb << 8) | rdi->first_track_last_session_lsb);
+
+	usi->session_first_track = 0;
+	usi->session_last_track = 0;
+	usi->session_start_addr = 0;
+	track_start_addr = 0;
+	track_size = 0;
+	free_blocks = 0;
+	nwa = 0;
+	lra = 0;
+	lra_valid = 0;
+	nwa_valid = 0;
+	for (track = usi->first_track; track <= usi->num_tracks; track++) {
+		error = cdreadtrackinfo(periph, (uint8_t *)ti, sizeof(*ti), 
+	       			track, /*sense_flags*/SF_NO_PRINT);
+		if (error != 0) {
+printf("Damn an error!\n");
+			goto out;
+		}
+		sessret = (ti->session_num_msb << 8) | ti->session_num_lsb;
+printf("Trackno: %u, sessret: %u, actual track: %u\n", (ti->track_num_msb << 8) | ti->track_num_lsb, sessret, track);
+		if (sessret == usi->session_num) {
+			if (usi->session_first_track == 0) {
+				usi->session_first_track = track;
+				usi->session_start_addr = scsi_4btoul(ti->track_start_addr);
+			}
+			usi->session_last_track = track;
+			track_start_addr = scsi_4btoul(ti->track_start_addr);
+			track_size = scsi_4btoul(ti->track_size);
+			free_blocks = scsi_4btoul(ti->free_blocks);
+			lra_valid = ti->valid_data & READ_TRACK_INFO_LRA_V;
+			lra = scsi_4btoul(ti->last_recorded_addr);
+			nwa_valid = ti->valid_data & READ_TRACK_INFO_NWA_V;
+			nwa =  scsi_4btoul(ti->next_writable_addr);
+		} 
+		else if (usi->session_first_track != 0)
+			break;
+	}
+	
+	if (usi->session_first_track == 0 || usi->session_last_track == 0) {
+printf("Session not found\n");
+		error = EINVAL;
+		goto out;
+	}
+
+	/* Calculate end address of session. */
+	usi->session_end_addr = track_start_addr + track_size - free_blocks - 1;
+printf("last address: %d, track_start_addr: %u, track_size: %u, free_blocks: %u\n", 
+		usi->session_end_addr, track_start_addr, track_size, free_blocks);
+	if (seqmedia == 1) {
+printf("last_rec_valid: %d, last_recorded_addr: %u, next_writ_valid: %d, next_writable_addr: %u, linkblkpenalty: %u\n",
+	lra_valid, lra, nwa_valid, nwa, linkblkpenalty);
+		if (lra_valid != 0)
+			usi->session_end_addr = lra;
+		/*else if (next_writ_valid != 0)
+			session_end_addr = next_writable_addr - linkblkpenalty;*/
+	}
+
+	usi->sector_size = 2048;
+	/* print the data */
+	printf("data from session number %d\n", usi->session_num);
+	printf("sector_size: %u\n", usi->sector_size); /* not sure the value can be anything different with cds or dvds */
+	printf("num_tracks: %u\n", usi->num_tracks);
+	printf("num_sessions: %u\n", usi->num_sessions);
+	printf("first_track: %u\n", usi->first_track);
+	printf("session first track: %u, last track %u\n", usi->session_first_track, usi->session_last_track);
+	printf("session first address: %d, last address: %d\n", usi->session_start_addr, usi->session_end_addr);
+out:
+	cam_periph_unlock(periph);
+	free(rdi, M_SCSICD);
+	free(ti, M_SCSICD);
+
+	return error;
+}
+
+#if 0
+static void
+funwithgetconf(struct cam_periph *periph) 
+{
+	struct scsi_get_conf_header *gch;
+	struct scsi_get_conf_feature_generic *fg;
+	uint32_t datalen;
+	uint32_t curprofile;
+	int error;
+
+	gch = malloc(sizeof(struct scsi_get_conf_header) + 1000,
+		M_SCSICD, M_WAITOK | M_ZERO);
+
+	cam_periph_lock(periph);
+
+	error = cdgetconf(periph, (u_int8_t *)gch, 
+		          sizeof (*gch) + 1000, GC_RT_ALLFEATURES, 0x0000, /*sense_flags*/SF_NO_PRINT);
+	if (error) {
+		free(gch, M_SCSICD);
+		cam_periph_unlock(periph);
+		printf("get conf error\n");
+	}
+
+	cam_periph_unlock(periph);
+
+	datalen = scsi_4btoul(gch->data_len);
+	curprofile = scsi_2btoul(gch->cur_profile);
+	printf("datalen %d, curprofile %x\n", datalen, curprofile);
+	switch (curprofile) {
+	case 0x03: /* Magneto-Optical disk with sector erase */
+	case 0x04: /* magneto-optical write only */
+	case 0x05: /* AS-MO */
+		printf("MO disk?\n");	
+		break;
+	case 0x00: /* Evedently this could be a CD-ROM? */
+	case 0x08: /* CD-ROM */
+	case 0x09: /* CD-R */ 
+	case 0x0A: /* CD-RW */
+		printf("CD-ROM\n");	
+		break;
+	case 0x10: /* DVD-ROM */
+	case 0x11: /* DVD-R Sequential recording */
+	case 0x12: /* DVD-RAM or DVD-RW */
+	case 0x13: /* DVD-RW Restricted Overwrite */
+	case 0x14: /* DVD-RW Sequential Recording */
+	case 0x1A: /* DVD+RW */
+	case 0x1B: /* DVD+R */
+	case 0x2A: /* DVD+RW Dual layer */
+	case 0x2B: /* DVD+R Dual layer */
+	case 0x50: /* HD DVD-ROM */
+	case 0x51: /* HD DVD-R */
+	case 0x52: /* HD DVD-RW; DVD-RAM like */
+		printf("DVD Drive\n");
+		break;
+	case 0x40: /* BD-ROM */
+	case 0x41: /* BD-R Sequential recording (SRM) */
+	case 0x42: /* BD-R Random Recording (RRM) */
+	case 0x43: /* BD-RE */
+		printf("BD-rom");
+		break;
+	default: 
+		printf("This shouldn't have happened\n");
+		break;
+	}
+
+	datalen -= 4; /* remainder of header */
+	fg = (struct scsi_get_conf_feature_generic *)(gch + 1); 
+	while (datalen > 0) {
+		printf("gch: %p, fg: %p\n", gch, fg);
+		printf("feature_code: %x\n", scsi_2btoul(fg->feature_code));
+		printf("additional_len: %d\n", fg->additional_len);
+		datalen -= 4 + fg->additional_len;
+		fg = (struct scsi_get_conf_feature_generic *)((uint8_t *)fg + 4 + fg->additional_len);
+	}
+
+	//bcopy(gch, addr, sizeof(*gch));
+	free(gch, M_SCSICD);
+}
+#endif
+
+static int 
+cdgetconf(struct cam_periph *periph, uint8_t *data, uint32_t len,
+	  uint8_t rt, uint16_t startfeature, uint32_t sense_flags)
+{
+	struct scsi_get_conf *scsi_cmd;
+        struct ccb_scsiio *csio;
+	union ccb *ccb;
+	int error;
+
+	error = 0;
+
+	ccb = cdgetccb(periph, CAM_PRIORITY_NORMAL);
+	csio = &ccb->csio;
+
+	cam_fill_csio(csio, 
+		      /* retries */ cd_retry_count, 
+		      /* cbfcnp */ cddone, 
+		      /* flags */ CAM_DIR_IN,
+		      /* tag_action */ MSG_SIMPLE_Q_TAG,
+		      /* data_ptr */ data,
+		      /* dxfer_len */ len,
+		      /* sense_len */ SSD_FULL_SIZE,
+		      sizeof(struct scsi_get_conf),
+ 		      /* timeout */ 50000);
+
+	scsi_cmd = (struct scsi_get_conf *)&csio->cdb_io.cdb_bytes;
+	bzero (scsi_cmd, sizeof(*scsi_cmd));
+	scsi_cmd->op_code = GET_CONFIGURATION;
+	scsi_cmd->byte2 = rt;
+	scsi_ulto2b(startfeature, scsi_cmd->start_feature);
+	scsi_ulto2b(len, scsi_cmd->alloc_len);
+
+	error = cdrunccb(ccb, cderror, /*cam_flags*/CAM_RETRY_SELTO,
+			 /*sense_flags*/SF_RETRY_UA | sense_flags);
+
+	xpt_release_ccb(ccb);
+
+	return(error);
+}
+
+static int
+cdreaddiscinfo(struct cam_periph *periph, uint8_t *data, uint32_t len, 
+	       uint32_t sense_flags)
+{
+	struct scsi_read_disc_info *scsi_cmd;
+        struct ccb_scsiio *csio;
+	union ccb *ccb;
+	int error;
+
+printf("data ptr: %p, len %d, sense_flags: %u\n", data, len, sense_flags);
+	error = 0;
+
+	ccb = cdgetccb(periph, CAM_PRIORITY_NORMAL);
+	csio = &ccb->csio;
+
+	cam_fill_csio(csio, 
+		      /* retries */ cd_retry_count, 
+		      /* cbfcnp */ cddone, 
+		      /* flags */ CAM_DIR_IN,
+		      /* tag_action */ MSG_SIMPLE_Q_TAG,
+		      /* data_ptr */ data,
+		      /* dxfer_len */ len,
+		      /* sense_len */ SSD_FULL_SIZE,
+		      sizeof(struct scsi_read_disc_info),
+ 		      /* timeout */ 50000);
+
+	scsi_cmd = (struct scsi_read_disc_info *)&csio->cdb_io.cdb_bytes;
+	bzero (scsi_cmd, sizeof(*scsi_cmd));
+	scsi_cmd->op_code = READ_DISC_INFO;
+	scsi_ulto2b(len, scsi_cmd->alloc_len);
+
+	error = cdrunccb(ccb, cderror, /*cam_flags*/CAM_RETRY_SELTO,
+			 /*sense_flags*/SF_RETRY_UA | sense_flags);
+
+	xpt_release_ccb(ccb);
+
+	return error;
+}
+
+static int
+cdreadtrackinfo(struct cam_periph *periph, uint8_t *data, uint32_t len, 
+	       uint32_t trackno, uint32_t sense_flags)
+{
+	struct scsi_read_track_info *scsi_cmd;
+        struct ccb_scsiio *csio;
+	union ccb *ccb;
+	int error;
+
+printf("data ptr: %p, len %d, trackno: %u, sense_flags: %u\n", data, len, trackno, sense_flags);
+	error = 0;
+
+	ccb = cdgetccb(periph, CAM_PRIORITY_NORMAL);
+	csio = &ccb->csio;
+
+	cam_fill_csio(csio, 
+		      /* retries */ cd_retry_count, 
+		      /* cbfcnp */ cddone, 
+		      /* flags */ CAM_DIR_IN,
+		      /* tag_action */ MSG_SIMPLE_Q_TAG,
+		      /* data_ptr */ data,
+		      /* dxfer_len */ len,
+		      /* sense_len */ SSD_FULL_SIZE,
+		      sizeof(struct scsi_read_track_info),
+ 		      /* timeout */ 50000);
+
+	scsi_cmd = (struct scsi_read_track_info *)&csio->cdb_io.cdb_bytes;
+	bzero (scsi_cmd, sizeof(*scsi_cmd));
+	scsi_cmd->op_code = READ_TRACK_INFO;
+	scsi_cmd->byte2 = READ_TRACK_INFO_AT_TRACK;
+	scsi_ulto4b(trackno, scsi_cmd->address);
+	scsi_ulto2b(len, scsi_cmd->alloc_len);
+
+	error = cdrunccb(ccb, cderror, /*cam_flags*/CAM_RETRY_SELTO,
+			 /*sense_flags*/SF_RETRY_UA | sense_flags);
+
+	xpt_release_ccb(ccb);
+
+	return error;
+}
+/* End of UDF code. */
+
 static void
 cdprevent(struct cam_periph *periph, int action)
 {
@@ -4273,3 +4713,4 @@ scsi_read_dvd_structure(struct ccb_scsiio *csio, u_int32_t retries,
 		      sizeof(*scsi_cmd),
 		      timeout);
 }
+
diff --git sys/cam/scsi/scsi_cd.h sys/cam/scsi/scsi_cd.h
index f502d66..9933b0c 100644
--- sys/cam/scsi/scsi_cd.h
+++ sys/cam/scsi/scsi_cd.h
@@ -56,6 +56,144 @@
  * SCSI command format
  */
 
+/* Used in UDF */
+
+#define GET_CONFIGURATION 0x46	/* cdrom read TOC */
+struct scsi_get_conf 
+{
+	uint8_t op_code;
+	uint8_t byte2;
+#define GC_RT_ALLFEATURES	0x00 /* Return header and all features active or not. */
+#define GC_RT_CURFEATURES	0x01 /* Return header and all active features. */
+#define GC_RT_ZEROFEATURES	0x02 /* Return header and zero or one feature. */
+	uint8_t start_feature[2];
+	uint8_t reserved[3];
+	uint8_t alloc_len[2];
+	uint8_t control;
+};
+
+struct scsi_get_conf_header
+{
+	uint8_t data_len[4];
+	uint8_t reserved[2];
+	uint8_t cur_profile[2];
+};
+
+struct scsi_get_conf_feature_generic
+{
+	uint8_t	feature_code[2];
+#define GC_FC_PROFILE_LIST		0x0000
+#define GC_FC_CORE			0x0001
+#define GC_FC_MORPHING			0x0002 
+#define GC_FC_REMOVABLE_MEDIUM		0x0003
+#define GC_FC_WRITE_PROTECT		0x0004
+#define GC_FC_RANDOM_READABLE		0x0010
+#define GC_FC_MULTIREAD			0x001D
+#define GC_FC_CD_READ			0x001E
+#define GC_FC_DVD_READ			0x001F
+#define GC_FC_RANDOM_WRITABLE		0x0020
+#define GC_FC_INCR_STREAMING_WRITABLE	0x0021
+#define GC_FC_SECTOR_ERASABLE		0x0022
+#define GC_FC_FORMATTABLE		0x0023
+#define GC_FC_DEFECT_MANAGEMENT 	0x0024
+#define GC_FC_WRITE_ONCE		0x0025
+#define GC_FC_RESTRICTED_OVERWRITE	0x0026
+#define GC_FC_CD_RW_CAV_WRITE		0x0027
+#define GC_FC_MRW_SUPPORT		0x0028 /* feature name guessed */
+#define GC_FC_DVD_READ_OPT_WRITE	0x002B /* feature name guessed */
+#define GC_FC_RIGID_RESTRICTED_OVERWRITE 0x002C
+#define GC_FC_CD_TRACK_AT_ONCE		0x002D
+#define GC_FC_CD_MASTERING		0x002E
+#define GC_FC_DVD_R_RW_WRITE		0x002F
+#define GC_FC_POWER_MANAGEMENT		0x0100
+#define GC_FC_SMART			0x0101
+#define GC_FC_EMBEDDED_CHANGER		0x0102
+#define GC_FC_CD_AUDIO_ANALOG_PLAY	0x0103
+#define GC_FC_MICROCODE_UPGRADE 	0x0104
+#define GC_FC_TIME_OUT 			0x0105
+#define GC_FC_DVD_CSS			0x0106
+#define GC_FC_REAL_TIME_STREAMING	0x0107
+#define GC_FC_LOGICAL_UNIT_SERIAL_NUMBER 0x0108
+#define GC_FC_DISC_CONTROL_BLOCKS	0x010A
+#define GC_FC_DVD_CPRM			0x010B
+	uint8_t	byte3;
+#define GC_CURRENT			0x1
+#define GC_PERSISTENT			0x2
+	uint8_t	additional_len;
+	uint8_t data[];
+};
+
+
+#define READ_DISC_INFO 0x51
+struct scsi_read_disc_info
+{
+	uint8_t op_code;
+	uint8_t byte2;
+	uint8_t reserved[5];
+	uint8_t alloc_len[2];
+	uint8_t control;
+};
+
+struct scsi_read_disc_info_data
+{
+	uint8_t disc_info_len[2];
+	uint8_t byte2;
+	uint8_t num_first_track;
+	uint8_t num_sessions_lsb;
+	uint8_t first_track_last_session_lsb;
+	uint8_t last_track_last_session_lsb;
+	uint8_t byte8;
+	uint8_t disc_type;
+	uint8_t num_sessions_msb;
+	uint8_t first_track_last_session_msb;
+	uint8_t last_track_last_session_msb;
+	uint8_t disc_id[4];
+	uint8_t leadin_start_last_session[4];
+	uint8_t last_start_time_leadout[4];
+	uint8_t disc_bar_code[8];
+	uint8_t reserved;
+	uint8_t num_opc_entries;
+	uint8_t opc_entries[];
+};
+
+
+#define READ_TRACK_INFO 0x52
+struct scsi_read_track_info
+{
+	uint8_t op_code;
+	uint8_t byte2;
+#define READ_TRACK_INFO_AT_LBA		0x00
+#define READ_TRACK_INFO_AT_TRACK	0x01
+#define READ_TRACK_INFO_AT_BORDER	0x02
+	uint8_t address[4];
+	uint8_t reserved;
+	uint8_t alloc_len[2];
+	uint8_t control;
+};
+
+struct scsi_read_track_info_data
+{
+	uint8_t track_info_len[2];
+	uint8_t track_num_lsb;
+	uint8_t session_num_lsb;
+	uint8_t reserved1;
+	uint8_t track_info1;
+	uint8_t track_info2;
+	uint8_t valid_data;
+#define READ_TRACK_INFO_LRA_V		0x2
+#define READ_TRACK_INFO_NWA_V		0x1
+	uint8_t track_start_addr[4];
+	uint8_t next_writable_addr[4];
+	uint8_t free_blocks[4];
+	uint8_t packet_size[4];
+	uint8_t track_size[4];
+	uint8_t last_recorded_addr[4];
+	uint8_t track_num_msb;
+	uint8_t session_num_msb;
+	uint8_t reserved2[2];
+};
+/* End of UDF */
+
 struct scsi_pause
 {
 	u_int8_t op_code;
diff --git sys/sys/udfio.h sys/sys/udfio.h
new file mode 100644
index 0000000..8260f00
--- /dev/null
+++ sys/sys/udfio.h
@@ -0,0 +1,29 @@
+
+
+/* Shared between kernel & process */
+
+#ifndef	_SYS_UDFIO_H_
+#define	_SYS_UDFIO_H_
+
+#ifndef _KERNEL
+#include <sys/types.h>
+#endif
+#include <sys/ioccom.h>
+
+
+struct udf_session_info {
+	uint32_t session_num;
+
+	uint16_t sector_size;
+	uint16_t num_sessions;
+	uint32_t session_start_addr;
+	uint32_t session_end_addr;
+
+	uint16_t num_tracks;
+	uint8_t  first_track;
+	uint16_t session_first_track;
+	uint16_t session_last_track;
+};
+#define	UDFIOTEST	_IOWR('c',300, struct udf_session_info)
+
+#endif /* !_SYS_UDFIO_H_ */
